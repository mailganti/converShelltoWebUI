import http.server
import http.client
import ssl
import socket
import logging
import os
import base64
import threading
from urllib.parse import urlparse
from cryptography import x509
from cryptography.hazmat.backends import default_backend

# Optional: For Windows Native Auth (NTLM/Kerberos)
try:
    import spnego
    SPNEGO_AVAILABLE = True
except ImportError:
    SPNEGO_AVAILABLE = False
    print("INFO: spnego not installed. Windows Native Auth disabled.")
    print("      Install with: pip install pyspnego")

# ============================================================
# CONFIGURATION
# ============================================================

# Proxy server configuration
BASE_DIR = os.getenv("BASE_DIR", "")
PROXY_HOST = '10.28.203.100'   # Listen on this IP
PROXY_PORT = 7585              # Listen on this port (clients connect here)

# Backend server configuration
BACKEND_HOST = '10.28.203.100'     # Hypercorn backend
BACKEND_PORT = 7605            # Hypercorn port
BACKEND_SSL = True             # Backend uses HTTPS

# SSL/TLS configuration
SERVER_CERT_FILE = BASE_DIR + '/controller/certs/cert.pem'       # Server certificate
SERVER_KEY_FILE = BASE_DIR + '/controller/certs/key.pem'         # Server private key
CA_CERT_FILE = BASE_DIR + '/controller/certs/certChain.pem'      # CA for client certs

# Client certificate verification
# ssl.CERT_NONE: No client certificate required
# ssl.CERT_OPTIONAL: Client can provide certificate (allows WNA fallback)
# ssl.CERT_REQUIRED: Client must provide certificate
CLIENT_CERT_REQUIRED = ssl.CERT_OPTIONAL

# Windows Native Auth configuration
ENABLE_WNA_FALLBACK = True     # Enable WNA when no client cert
WNA_SERVICE_NAME = "HTTP"      # Kerberos service name

# Headers to pass identity to backend (matching existing main.py)
CERT_CN_HEADER = "X-Client-Cert-CN"      # Certificate Common Name
CERT_DN_HEADER = "X-Client-Cert-DN"      # Certificate Distinguished Name
AUTH_METHOD_HEADER = "X-Auth-Method"     # Auth method used

# Default domain for Smart Card auth (set to your org's domain)
DEFAULT_DOMAIN = ""  # <-- CHANGE THIS to your domain (e.g., "CORP", "AGENCY")

# Logging
LOG_LEVEL = logging.INFO
LOG_FORMAT = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'

# ============================================================
# LOGGING SETUP
# ============================================================

logging.basicConfig(level=LOG_LEVEL, format=LOG_FORMAT)
logger = logging.getLogger('ssl_proxy')

# ============================================================
# SPNEGO AUTH MANAGER
# ============================================================

class SPNEGOAuthManager:
    """Manages SPNEGO authentication contexts for connections"""
    
    def __init__(self):
        self._contexts = {}
        self._lock = threading.Lock()
    
    def get_or_create_context(self, connection_id: str):
        """Get existing or create new SPNEGO context"""
        if not SPNEGO_AVAILABLE:
            return None
            
        with self._lock:
            if connection_id not in self._contexts:
                try:
                    self._contexts[connection_id] = spnego.server(
                        service=WNA_SERVICE_NAME,
                        hostname=socket.gethostname()
                    )
                except Exception as e:
                    logger.error(f"Failed to create SPNEGO context: {e}")
                    return None
            return self._contexts[connection_id]
    
    def remove_context(self, connection_id: str):
        """Remove completed context"""
        with self._lock:
            self._contexts.pop(connection_id, None)
    
    def authenticate(self, connection_id: str, auth_header: str):
        """
        Process SPNEGO authentication.
        
        Returns: (success, username, challenge_token)
            - success: True if auth complete
            - username: Authenticated user (if success)
            - challenge_token: Token to send in WWW-Authenticate (if not complete)
        """
        ctx = self.get_or_create_context(connection_id)
        if not ctx:
            return False, None, None
        
        try:
            # Parse incoming token
            in_token = None
            if auth_header and auth_header.lower().startswith('negotiate '):
                in_token = base64.b64decode(auth_header[10:])
            
            # Process token
            out_token = ctx.step(in_token)
            
            if ctx.complete:
                # Authentication successful
                username = str(ctx.client_principal) if ctx.client_principal else None
                self.remove_context(connection_id)
                return True, username, None
            else:
                # Need another round
                challenge = base64.b64encode(out_token).decode() if out_token else ""
                return False, None, f"Negotiate {challenge}"
                
        except Exception as e:
            logger.error(f"SPNEGO auth error: {e}")
            self.remove_context(connection_id)
            return False, None, None


# Global SPNEGO manager
spnego_manager = SPNEGOAuthManager()

# ============================================================
# CERTIFICATE PARSING
# ============================================================

def extract_cert_identity(cert_der: bytes) -> tuple:
    """
    Extract identity from client certificate.
    
    Returns: (username, domain, cert_dn)
    """
    try:
        cert = x509.load_der_x509_certificate(cert_der, default_backend())
        subject = cert.subject
        
        # Extract Common Name
        cn = None
        for attr in subject:
            if attr.oid == x509.oid.NameOID.COMMON_NAME:
                cn = attr.value
                break
        
        # Build DN string
        dn_parts = []
        for attr in subject:
            dn_parts.append(f"{attr.oid._name}={attr.value}")
        cert_dn = ", ".join(dn_parts)
        
        # Use hardcoded domain from config
        domain = DEFAULT_DOMAIN
        
        username = cn or "unknown"
        
        return username, domain, cert_dn
        
    except Exception as e:
        logger.error(f"Error parsing certificate: {e}")
        return None, None, None


def parse_wna_identity(identity: str) -> tuple:
    """
    Parse Windows identity string.
    
    Supports: DOMAIN\\user, user@domain.com, user
    Returns: (username, domain)
    """
    if not identity:
        return None, None
    
    if '\\' in identity:
        parts = identity.split('\\', 1)
        return parts[1], parts[0].upper()
    
    if '@' in identity:
        parts = identity.split('@', 1)
        domain = parts[1].split('.')[0].upper()
        return parts[0], domain
    
    return identity, None

# ============================================================
# PROXY HANDLER
# ============================================================

class DualAuthProxyHandler(http.server.BaseHTTPRequestHandler):
    """HTTP request handler with Smart Card + WNA authentication"""
    
    # Connection tracking for SPNEGO
    _connection_counter = 0
    _connection_lock = threading.Lock()
    
    def __init__(self, *args, **kwargs):
        # Generate unique connection ID
        with self._connection_lock:
            DualAuthProxyHandler._connection_counter += 1
            self._connection_id = f"conn_{DualAuthProxyHandler._connection_counter}"
        
        self._auth_user = None
        self._auth_method = None
        self._cert_dn = None
        
        super().__init__(*args, **kwargs)
    
    def log_message(self, format, *args):
        """Override to use our logger"""
        logger.info(f"{self.client_address[0]} - {format % args}")
    
    def _authenticate(self) -> bool:
        """
        Perform authentication.
        
        1. Try client certificate (Smart Card)
        2. If no cert, try Windows Native Auth (SPNEGO)
        
        Returns: True if authenticated, False if 401 sent
        """
        # Try certificate authentication first
        if hasattr(self.connection, 'getpeercert'):
            cert_der = self.connection.getpeercert(binary_form=True)
            if cert_der:
                username, domain, cert_dn = extract_cert_identity(cert_der)
                if username:
                    self._auth_user = f"{domain}\\{username}" if domain else username
                    self._auth_method = "smartcard"
                    self._cert_dn = cert_dn
                    logger.info(f"[{self.client_address[0]}] Smart Card auth: {self._auth_user}")
                    return True
        
        # Fall back to Windows Native Auth
        if ENABLE_WNA_FALLBACK and SPNEGO_AVAILABLE:
            auth_header = self.headers.get('Authorization', '')
            
            if auth_header.lower().startswith('negotiate'):
                # Process SPNEGO token
                success, username, challenge = spnego_manager.authenticate(
                    self._connection_id, auth_header
                )
                
                if success and username:
                    user, domain = parse_wna_identity(username)
                    self._auth_user = f"{domain}\\{user}" if domain else user
                    self._auth_method = "wna"
                    self._cert_dn = f"CN={user}"  # Minimal DN for WNA
                    logger.info(f"[{self.client_address[0]}] WNA auth: {self._auth_user}")
                    return True
                elif challenge:
                    # Send 401 with challenge
                    self.send_response(401)
                    self.send_header('WWW-Authenticate', challenge)
                    self.send_header('Content-Length', '0')
                    self.send_header('Connection', 'keep-alive')
                    self.end_headers()
                    return False
            
            # No auth header - send initial 401 with Negotiate
            self.send_response(401)
            self.send_header('WWW-Authenticate', 'Negotiate')
            self.send_header('Content-Type', 'text/html')
            body = b'<html><body><h1>401 Authentication Required</h1></body></html>'
            self.send_header('Content-Length', str(len(body)))
            self.end_headers()
            self.wfile.write(body)
            return False
        
        # No authentication available
        logger.warning(f"[{self.client_address[0]}] No authentication provided")
        self.send_error(401, "Authentication required")
        return False
    
    def _proxy_request(self, method: str):
        """Proxy request to backend with auth headers"""
        try:
            # Authenticate first
            if not self._authenticate():
                return  # 401 already sent
            
            # Connect to backend (HTTP or HTTPS)
            if BACKEND_SSL:
                # Create unverified context for internal backend
                import ssl as ssl_internal
                backend_ctx = ssl_internal._create_unverified_context()
                conn = http.client.HTTPSConnection(
                    BACKEND_HOST, 
                    BACKEND_PORT, 
                    timeout=30, 
                    context=backend_ctx
                )
            else:
                conn = http.client.HTTPConnection(BACKEND_HOST, BACKEND_PORT, timeout=30)
            
            # Build path with query string
            path = self.path
            
            # Copy headers, add auth headers
            headers = {}
            for key, value in self.headers.items():
                # Skip hop-by-hop headers
                if key.lower() not in ('connection', 'keep-alive', 'proxy-authenticate',
                                        'proxy-authorization', 'te', 'trailers',
                                        'transfer-encoding', 'upgrade', 'authorization'):
                    headers[key] = value
            
            # Add authentication headers (matching main.py expectations)
            if self._auth_user:
                # Extract just the username (CN) without domain for x-client-cert-cn
                if '\\' in self._auth_user:
                    cn_only = self._auth_user.split('\\', 1)[1]
                else:
                    cn_only = self._auth_user
                headers[CERT_CN_HEADER] = cn_only
            if self._auth_method:
                headers[AUTH_METHOD_HEADER] = self._auth_method
            if self._cert_dn:
                headers[CERT_DN_HEADER] = self._cert_dn
            
            # Add forwarding headers
            headers['X-Forwarded-For'] = self.client_address[0]
            headers['X-Forwarded-Proto'] = 'https'
            
            # Read request body if present
            body = None
            content_length = self.headers.get('Content-Length')
            if content_length:
                body = self.rfile.read(int(content_length))
            
            # Make request to backend
            conn.request(method, path, body=body, headers=headers)
            
            # Get response
            response = conn.getresponse()
            
            # Send response to client
            self.send_response(response.status)
            
            # Copy response headers
            for key, value in response.getheaders():
                if key.lower() not in ('transfer-encoding', 'connection'):
                    self.send_header(key, value)
            self.end_headers()
            
            # Copy response body
            self.wfile.write(response.read())
            
            conn.close()
            
        except Exception as e:
            logger.error(f"Proxy error: {e}")
            self.send_error(502, f"Bad Gateway: {str(e)}")
    
    def do_GET(self):
        self._proxy_request('GET')
    
    def do_POST(self):
        self._proxy_request('POST')
    
    def do_PUT(self):
        self._proxy_request('PUT')
    
    def do_DELETE(self):
        self._proxy_request('DELETE')
    
    def do_PATCH(self):
        self._proxy_request('PATCH')
    
    def do_OPTIONS(self):
        self._proxy_request('OPTIONS')
    
    def do_HEAD(self):
        self._proxy_request('HEAD')

# ============================================================
# MAIN SERVER
# ============================================================

def create_ssl_context():
    """Create SSL context for the proxy server"""
    context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
    
    # Load server certificate
    context.load_cert_chain(SERVER_CERT_FILE, SERVER_KEY_FILE)
    
    # Load CA for client certificate verification
    try:
        context.load_verify_locations(CA_CERT_FILE)
        context.verify_mode = CLIENT_CERT_REQUIRED
        logger.info(f"Client cert verification: {CLIENT_CERT_REQUIRED}")
    except Exception as e:
        logger.warning(f"Could not load CA cert: {e}")
        context.verify_mode = ssl.CERT_NONE
    
    # Modern TLS settings
    context.minimum_version = ssl.TLSVersion.TLSv1_2
    
    return context


def run_proxy():
    """Start the proxy server"""
    # Create SSL context
    ssl_context = create_ssl_context()
    
    # Create HTTP server
    server_address = (PROXY_HOST, PROXY_PORT)
    httpd = http.server.HTTPServer(server_address, DualAuthProxyHandler)
    
    # Wrap with SSL
    httpd.socket = ssl_context.wrap_socket(
        httpd.socket,
        server_side=True
    )
    
    # Print startup info
    logger.info("=" * 60)
    logger.info("Dual Authentication SSL Proxy")
    logger.info("=" * 60)
    logger.info(f"Listening on: https://{PROXY_HOST}:{PROXY_PORT}")
    logger.info(f"Backend: http://{BACKEND_HOST}:{BACKEND_PORT}")
    logger.info(f"Smart Card Auth: Enabled (CERT_{CLIENT_CERT_REQUIRED})")
    logger.info(f"Windows Native Auth: {'Enabled' if (ENABLE_WNA_FALLBACK and SPNEGO_AVAILABLE) else 'Disabled'}")
    logger.info("=" * 60)
    logger.info("Press Ctrl+C to stop")
    
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        logger.info("Shutting down...")
        httpd.shutdown()


if __name__ == '__main__':
    run_proxy()
