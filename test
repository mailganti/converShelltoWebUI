{"client_host":"172.27.93.75","all_headers":{"host":"ds-d1-ebs-01.ba.ssa.gov:7605","sec-ch-ua":"\"Chromium\";v=\"142\", \"Microsoft Edge\";v=\"142\", \"Not_A Brand\";v=\"99\"","sec-ch-ua-mobile":"?0","sec-ch-ua-platform":"\"Windows\"","upgrade-insecure-requests":"1","user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36 Edg/142.0.0.0","accept":"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7","sec-fetch-site":"none","sec-fetch-mode":"navigate","sec-fetch-user":"?1","sec-fetch-dest":"document","accept-encoding":"gzip, deflate, br, zstd","accept-language":"en-US,en;q=0.9","x_cryptokeeper_installed":"1","x_cryptokeeper_version":"3.7","priority":"u=0, i"}}



@app.get("/debug-headers")
async def debug_headers(request: Request):
    return {
        "client_host": request.client.host if request.client else "unknown",
        "all_headers": dict(request.headers),
    }


@app.get("/debug-headers")
async def debug_headers(request: Request):
    return {
        "client_host": request.client.host,
        "all_headers": dict(request.headers),
        "expected_user_header": AUTH_CONFIG.AUTH_USER_HEADER,
        "expected_method_header": AUTH_CONFIG.AUTH_METHOD_HEADER,
    }


import asyncio
import ssl

async def test():
    # Connect to backend directly
    r, w = await asyncio.open_connection('localhost', 8000)
    
    # Send request
    req = b"GET / HTTP/1.1\r\nHost: localhost:8000\r\nConnection: close\r\n\r\n"
    w.write(req)
    await w.drain()
    
    # Read response
    response = b""
    while True:
        chunk = await r.read(4096)
        if not chunk:
            break
        response += chunk
    
    print(f"Got {len(response)} bytes")
    print(response[:500].decode('utf-8', errors='replace'))
    w.close()

asyncio.run(test())




@app.middleware("http")
async def check_proxy_auth(request: Request, call_next):
    # If proxy already authenticated, set user in state
    proxy_user = request.headers.get("X-Authenticated-User")
    if proxy_user:
        request.state.user = proxy_user
        request.state.authenticated = True
    
    response = await call_next(request)
    return response






async def get_current_user(request: Request) -> Optional[DualAuthUser]:
    """
    Extract authenticated user from proxy headers.
    Returns None if not authenticated (use require_auth for mandatory auth).
    """
    # Get auth headers
    identity = request.headers.get(AUTH_CONFIG.AUTH_USER_HEADER)
    auth_method = request.headers.get(AUTH_CONFIG.AUTH_METHOD_HEADER, "unknown")
    cert_dn = request.headers.get(AUTH_CONFIG.CERT_DN_HEADER)

    if not identity:
        return None

    # Validate trusted proxy
    if not is_trusted_proxy(request):
        logger.warning(f"Auth header from untrusted source: {request.client.host}")
        return None

    # Parse identity
    username, domain = parse_identity(identity)

    if not username:
        return None

    # Build display name
    display_name = None
